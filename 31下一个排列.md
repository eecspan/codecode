## 题干：

整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。

- 例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。

整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。

- 例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。
- 类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。
- 而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。

给你一个整数数组 nums ，找出 nums 的下一个排列。

必须 **原地** 修改，只允许使用额外常数空间。



- 示例 1：

输入：nums = [1,2,3]
输出：[1,3,2]

- 示例 2：

输入：nums = [3,2,1]
输出：[1,2,3]

- 示例 3：

输入：nums = [1,1,5]
输出：[1,5,1]



## 思路：

这题最重要的一个思路为：考虑一个原始排列：10, 9, 11, 6, 8, 7, 5, 4, 3, 2, 1，按照字典序生成，我们要找到其下一个序列。我们可以观察看其中的一个子序列8, 7, 5, 4, 3, 2, 1，该子序列单调递减，如果我们将其看做一个序列，这已经是字典序最大的排列了，因此其下一个排列要从头开始，即1, 2, 3, 4, 5, 7, 8。我们考虑这一个完整的序列10, 9, 11, 6, 8, 7, 5, 4, 3, 2, 1，我们可以先将其转换为10, 9, 11, 6, 1, 2, 3, 4, 5, 7, 8，我们只需要将6和7交换一下，变成10, 9, 11, 7, 1, 2, 3, 4, 5, 6, 8，那么这就是10, 9, 11, 6, 8, 7, 5, 4, 3, 2, 1的下一个序列。

所以总结一下，我们找一个序列的字典序增大的下一个序列，我们就是从后往前，先找到一个从后往前递增的子序列，他在序列的x位置终止（假设x >= 0），也就是x位置的数字要小于x+1位置的数字。那么因为x之后已经是个单调递减序列了，这个子序列已经是字典序最大，因此我们只能从这个子序列里找比x位置数字大的最小的那个数字，将其与x位置的数字交换后，再把这个子序列按递增顺序排列，也就是字典序最小的顺序排列。

所以方法就确定了，从后往前找到单调递增（从后往前）的子序列（相等的也算进去），分界数字的位置为x。之后将该子序列逆序，并找到子序列中第一个大于x位置数字的数字，并将其与x位置数字交换，这就是所求。

我们使用`std::reverse(nums.begin(), nums.end())`，对vector反转。